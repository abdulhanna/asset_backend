import StatusCodes from "http-status-codes";
import createError from "http-errors-lite";
import {assert, assertEvery} from "../../../helpers/mad-assert";
import { masterTableColumnModel, masterTableModel } from '../models';
import autoCodeGeneration from "../../../helpers/autoGeneratedCode";
import globalDetails from "../../../helpers/globalDetails";
import ExcelJS from "exceljs";
import mongoose from "mongoose";
import {secret} from "../../../config/secret";


const masterTableService = {}

///////// adding table column and generating sheet ///////////
masterTableService.createMasterTable = async (data, dashboardPermission, organizationId) => {

     const organizationName = await globalDetails.getOrganizationName(
         organizationId
     );

     const finalMSTCodeId = data.codeGenerationType === 'manual' ? data.tableCodeId : await autoCodeGeneration.getmstCode(organizationName);

     const finalOrganizationId = dashboardPermission === 'root_dashboard' ? null : organizationId;


        const getExistingtable = await masterTableColumnModel.findOne({
             organizationId: finalOrganizationId,
             tableName: data.tableName,
             isDeleted: false,
        })

        assert(!getExistingtable, createError(StatusCodes.CONFLICT, "Table Name already exists"))

        const newMstTable = new masterTableColumnModel({
             organizationId: organizationId,
             codeGenerationType: data.codeGenerationType,
             tableCodeId: finalMSTCodeId,
             tableName: data.tableName,
             applicableTo: data.applicableTo,
             applicableId: data.applicableId,
             fields: data.fields
        })
        const savedMstTableColumn = await newMstTable.save();
        assert(
            savedMstTableColumn,
            createError(StatusCodes.REQUEST_TIMEOUT, "Request Timeout")
        );

        const workbook = new ExcelJS.Workbook();
        const worksheet = workbook.addWorksheet('MasterTable');

        // sheet headers
        const fields = savedMstTableColumn.fields;

    // Write headers to the Excel sheet
    const headers = fields.map((field) => {
        return field.depreciationType
            ? `${field.fieldName} (${field.depreciationType})`
            : field.fieldName;
    });
   const headerRow = worksheet.addRow(headers);

    // Set background color for the header row
    headerRow.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: '19c37d' },
    };


    // Set font size for header cells
    headerRow.font = {
        size: 12,
        bold: true,
    };


    worksheet.columns.forEach((column, i) => {
        let maxLength = 0;
        column.eachCell((cell) => {
            const columnLength = cell.value ? cell.value.toString().length : 20;
            if (columnLength > maxLength) {
                maxLength = columnLength;
            }
        });
        column.width = maxLength < 20 ? 20: maxLength;
    });



    // Add data validation to sheet columns based on data type for up to 1000 rows
    fields.forEach((field, index) => {
        const colNum = index + 1;
        let dataValidation;
        if (field.dataType === 'number') {
            dataValidation = {
                type: 'decimal',
                operator: 'greaterThan',
                formulae: [0],
                allowBlank: true,
                showErrorMessage: true,
                errorTitle: 'Invalid Data',
                error: 'Please enter a valid Rate.',
            };
        } else {
            // For alphanumeric data, specify a custom formula (text validation)
            dataValidation = {
                type: 'textLength',
                operator: 'lessThanOrEqual',
                formulae: [50], // Maximum text length allowed (adjust as needed)
                allowBlank: true,
                showErrorMessage: true,
                errorTitle: 'Invalid Data',
                error: 'Text is too long. Maximum length is 50 characters.',
            };
        }


        // Apply data validation to rows 2 to 1001 (1000 rows)
        for (let row = 1; row <= 1000; row++) {
            const cell = worksheet.getCell(row, colNum);
            cell.dataValidation = dataValidation;
        }
    });


    // Protect the worksheet to prevent editing in other cells
    worksheet.protect('Pushpa@1102');
    worksheet.sheetProtection.sheet = true;
    worksheet.sheetProtection.insertRows = false;
    worksheet.sheetProtection.formatCells = false;




    // Iterate over each row up to 1000 rows
    for (let rowNumber = 2; rowNumber <= 1000; rowNumber++) {
        const row = worksheet.getRow(rowNumber);

        // Iterate over each header cell
        headerRow.eachCell((headerCell, colNumber) => {
            const cell = row.getCell(colNumber);
            cell.protection = {
                locked: false
            };
        });
    }

    // remove white space from table name
        const sampleFileName = savedMstTableColumn.tableName.split(" ").join("");

        // file path
        const excelFilePath = 'public/exports/masterTables/'+sampleFileName+'_'+'SampleFile'+'.xlsx';

        // Save the Excel file
       const fileCreated =  await workbook.xlsx.writeFile(excelFilePath);
       assert(!fileCreated, createError(StatusCodes.BAD_REQUEST, "Error in creating sample file for Master Table"))

        const fileUrl = secret.backend_baseURL+'/exports/masterTables/'+sampleFileName+'_'+'SampleFile'+'.xlsx';
        return  {'SampleFile':fileUrl,'tableCodeId':savedMstTableColumn.tableCodeId};
};


////////// upload table data ////////////
masterTableService.uploadMasterTableData = async (filePath, tableCodeId, addedByUserId) => {

    assertEvery(
        [tableCodeId, filePath],
        createError(
            StatusCodes.BAD_REQUEST,
            "Invalid Data: tableCodeId and file must exist"
        )
    );

    const getTableId = await masterTableColumnModel.findOne({tableCodeId: tableCodeId})
    assert(getTableId, createError(StatusCodes.BAD_REQUEST, `No table exist with tableCodeId ${tableCodeId}`))

    const tableId = getTableId._id;
    const workbook = new ExcelJS.Workbook();
    await workbook.xlsx.readFile(filePath);

    // Assuming you have a worksheet named 'MasterTable' in the Excel file
    const worksheet = workbook.getWorksheet('MasterTable');
    assert(worksheet, createError(StatusCodes.INTERNAL_SERVER_ERROR, "Error in uploading data. Worksheet 'MasterTable' not found in the Excel file."))

    // Assuming the headers are in the first row of the sheet
    const headerRow = worksheet.getRow(1);
    const headers = headerRow.values;

    // Assuming the headers match your schema's field names and data types
    const data = [];

    worksheet.eachRow({ includeEmpty: false }, (row, rowNumber) => {
        if (rowNumber > 1) { // Skip the header row
            const rowData = {};
            row.eachCell({ includeEmpty: false }, (cell, colNumber) => {
                // Use headers[1] to get the correct header for the column
                rowData[headers[colNumber]] = cell.value;
            });
            data.push(rowData);
        }
    });

    // Perform data validation on 'data' if needed

    // Create a new document in the masterTableSchema
    const masterTable = new masterTableModel({
        tableId,
        masterTableData: data,
        addedByUserId,
        createdAt: Date.now()
    });

    const savedMasterTable = await masterTable.save();

    assert(savedMasterTable, createError(StatusCodes.INTERNAL_SERVER_ERROR, "Error in uploading Data"))
    return savedMasterTable;
}


////// get all table //////////
masterTableService.getallTable = async (dashboardPermission, organizationId) => {
    let finalOrganizationId;

    if (dashboardPermission === 'root_dashboard') {
        finalOrganizationId = null;
    } else
    {
        finalOrganizationId = mongoose.Types.ObjectId(organizationId);
    }


     const allTables = await masterTableModel.aggregate([
        {
            $match: {
                isDeleted: false // Filter out deleted masterTables
            }
        },
        {
            $lookup: {
                from: 'mastertablecolumns',
                localField: 'tableId', // Field from the masterTables collection
                foreignField: '_id', // Field from the masterTableColumns collection
                as: 'tableColumns'
            }
        },
         {
             $match: {
                 'tableColumns.organizationId': finalOrganizationId
             }
         },
         {
             $unwind: '$tableColumns' // Deconstruct the array created by the lookup
         },
         {
             $lookup: {
                 from: 'users',
                 localField: 'addedByUserId', // Field from the masterTables collection
                 foreignField: '_id', // Field from the masterTableColumns collection
                 as: 'userData'
             }
         },
         {
             $unwind: '$userData' // Deconstruct the array created by the lookup
         },
         {
             $project: {
                 '_id': 1,
                 'tableCodeId': '$tableColumns.tableCodeId',
                 'tableName': '$tableColumns.tableName',
                 'applicableTo': '$tableColumns.applicableTo',
                 'applicableId': '$tableColumns.applicableId',
                 'createdBy': '$userData.email',
                 'createdAt': 1
             }
         }
    ]);


    assert(allTables, createError(StatusCodes.REQUEST_TIMEOUT, "Request Timeout"));
     return allTables;
}


export default masterTableService;