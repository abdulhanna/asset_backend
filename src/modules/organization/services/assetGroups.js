import StatusCodes from "http-status-codes";
import createError from "http-errors-lite";
import globalDetails from "../../../helpers/globalDetails";
import autoCodeGeneration from "../../../helpers/autoGeneratedCode";
import { assert, assertEvery } from "../../../helpers/mad-assert"; 
import { assetGroupModel, locationModel } from "../models";


const assetGroupService = {};

// create new group
assetGroupService.createAssetGroup = async (
     name,
     codeGenerationType,
     assetCodeId,
     description,
     parentId,
     organizationId,
) =>{
     assertEvery(
          [name, codeGenerationType, description],
          createError(
            StatusCodes.BAD_REQUEST,
            "Invalid Data: [name], [codeGenerationType] and [description] fields must exist"
          )
        );

         assert(!assetCodeId && codeGenerationType != 'manual', createError(StatusCodes.BAD_REQUEST, "assetCodeId is mandatory"))
        const organizationName = await globalDetails.getOrganizationName(organizationId);
        const finalassetCodeId = codeGenerationType === 'manual' ? assetCodeId : await autoCodeGeneration.getassetGrpCode(organizationName);  
        const existingGroupName = await assetGroupModel.findOne({ 
           name,
           organizationId,
           isDeleted: false
         });
        assert(!existingGroupName, createError(StatusCodes.BAD_REQUEST, 'Asset Group name already exists'));
      
        const existingGroupCode = await assetGroupModel.findOne({ 
          assetCodeId:finalassetCodeId,
          organizationId:organizationId
      })
     assert(!existingGroupCode, createError(StatusCodes.BAD_REQUEST, "Asset Group Identification No. already exist"))

 if(parentId)
 {
    await assetGroupModel.findByIdAndUpdate(parentId,
     {isParent: true})
 }
 const newAssetGroup = new assetGroupModel({
     name:name,
     assetCodeId:finalassetCodeId,
     organizationId:organizationId,
     description:description,
     parentId: parentId ? parentId : null,
     createdAt: Date.now()

 })
 const savedassetGroup = await newAssetGroup.save();
      assert(
          savedassetGroup,
        createError(StatusCodes.REQUEST_TIMEOUT, "Request Timeout")
      );   

      return savedassetGroup;
}


// edit group data
assetGroupService.editAssetGroup = async (id, data, organizationId)=>{
  const assetGroupData = {};
  if(data.name)
  {
     assetGroupData.name = data.name;
     const existingGroupName = await assetGroupModel.findOne({
          name : assetGroupData.name,
          organizationId:organizationId,
          _id: { $ne: id },
          
     })
     assert(!existingGroupName, createError(StatusCodes.BAD_REQUEST, "Asset Group name already exist"))
  }
  if(data.assetCodeId)
  {
     assetGroupData.assetCodeId = data.assetCodeId;
     const existingGroupCode = await assetGroupModel.findOne({
          assetCodeId : assetGroupData.assetCodeId,
          organizationId:organizationId,
          _id: { $ne: id }
     })
     assert(!existingGroupCode, createError(StatusCodes.BAD_REQUEST, "Asset Group Identification No. already exist"))
  }
  if(data.description)
  {
     assetGroupData.description = data.description;
  }
  if(data.parentId)
  {
     assetGroupData.parentId = data.parentId;
     await assetGroupModel.findByIdAndUpdate(
         {_id: assetGroupData.parentId},
          {isParent: true})
  }
  assetGroupData.updatedAt = Date.now();

  const result = await assetGroupModel.findByIdAndUpdate(
     { _id: id },
     {
       $set: assetGroupData
     },
     { new: true }
   );

   assert(
     result,
   createError(StatusCodes.REQUEST_TIMEOUT, "Request Timeout")
 ); 
 return result;
}

////// Get Asset Group By Id ////////////
assetGroupService.getAssetGroupbyId = async (id) =>{
     const assetgrpData = await assetGroupModel.findById(id).select({
          organizationId: 0,
          isDeleted: 0,
          deletedAt: 0,
          createdAt: 0,
          updatedAt: 0,
          __v: 0,
        });
     assert(assetgrpData, createError(StatusCodes.REQUEST_TIMEOUT, "Request Time out"))
     return assetgrpData;
}

///////// listing by hierarchy ////////////
assetGroupService.getAssetGroupsHierarchyByOrganizationId = async (organizationId) => {

          const assetGroups = await assetGroupModel.find(
               { organizationId,
                    isDeleted: false
               }
               ).select({
                    isDeleted: 0,
                    deletedAt: 0,
                    organizationId: 0,
                    __v: 0,
                  });
          assert(assetGroups, createError(StatusCodes.REQUEST_TIMEOUT, "Request Timeout"))
          // Function to convert the asset groups into a hierarchical structure
          const convertToHierarchy = (nodes) => {
               const hierarchy = [];
               const map = new Map();

               nodes.forEach((node) => {
                    map.set(node._id.toString(), {
                         ...node.toObject(),
                         children: [],
                    });
               });

               nodes.forEach((node) => {
                    const parent = map.get(node._id.toString());

                    if (node.parentId) {
                         const parentassetGroup = map.get(
                              node.parentId.toString()
                         );
                         if (parentassetGroup) {
                              parentassetGroup.children.push(parent);
                         }
                    } else {
                         hierarchy.push(parent);
                    }
               });

               return hierarchy;
          };
          const hierarchicalLocations = convertToHierarchy(assetGroups);
          return hierarchicalLocations;   
};



//////// listing without hierarchy //////////////
assetGroupService.getAssetGroupsByOrganizationId = async (organizationId, assignedLocationId, page, limit, sortBy, sortOrder) => {

     const totalassetGroups = await assetGroupModel.countDocuments();
     const totalPages = Math.ceil(totalassetGroups / limit);
   
     let startSerialNumber = (page - 1) * limit + 1;  
     let endSerialNumber = Math.min(page * limit, totalassetGroups);
     
   
     if(assignedLocationId && organizationId)
     {
         
         const LocassetGroups = await locationModel.find(
               { _id: assignedLocationId,
                 isDeleted: false
               }
               )
               .select('_id')
               .populate({
                    path: 'assetgroups.assetgroupId',
                    model: 'assetgroups',
                    sort: { [sortBy]: sortOrder },
                    skip: (page - 1) * limit,
                    limit: limit,
                    select: '-isDeleted -deletedAt -organizationId -__v'
               })

               assert(LocassetGroups, createError(StatusCodes.REQUEST_TIMEOUT, "Request Timeout"));
               const assetgroups = LocassetGroups[0].assetgroups.map(item => item.assetgroupId);

               return {
                    page,
                    totalPages,
                    totalassetGroups,
                    startSerialNumber,
                    endSerialNumber,
                    assetGroups,
                  };

     }

     else if(organizationId){

     
        const assetGroups = await assetGroupModel.find(
          { organizationId,
            isDeleted: false
          }
          ).sort({ [sortBy]: sortOrder })
          .skip((page - 1) * limit)
          .limit(limit)
          .select('-isDeleted -deletedAt -organizationId -__v');

             assert(assetGroups, createError(StatusCodes.REQUEST_TIMEOUT, "Request Timeout"))

             return {
               page,
               totalPages,
               totalassetGroups,
               startSerialNumber,
               endSerialNumber,
               assetGroups,
             };
     }

}




///////////// Modal View ///////////

assetGroupService.modalViewAssetgroups = async (organizationId, assignedLocationId) => {
     // Fetch all asset groups from the assetGroupModel
    const assetGroups = await assetGroupModel.find(
     { organizationId,
     isDeleted: false
   })
   .select('-isDeleted -deletedAt -organizationId -__v');
   assert(assetGroups, createError(StatusCodes.REQUEST_TIMEOUT, "Request Timeout"))

    // Add the 'isExist' property to each asset group
    const assetGroupsWithExistProperty = await Promise.all(assetGroups.map(async assetGroup => {
     const isExist = await checkAssetGroupExistence(assignedLocationId, assetGroup._id);
     return { ...assetGroup.toObject(), isExist };
   }));

    return assetGroupsWithExistProperty;
   console.log(assetGroupsWithExistProperty);

}




const checkAssetGroupExistence = async (locationId, assetGroupId) => {
     try {
       // Find the location by its ID
       const location = await locationModel.findById(locationId);
       // Check if the location exists and contains the asset group
       if (location && location.assetgroups.some(assetgroup => assetgroup.assetgroupId.equals(assetGroupId))) {
         return true; // Asset group exists in the location
       }
   
       return false; // Asset group doesn't exist in the location
     } catch (error) {
       console.error('Error:', error);
       return false;
     }
   };





//////////// delete assetgroup ////////
assetGroupService.deleteAssetgroup = async (id) => {
     const assetGroups = await assetGroupModel.updateMany(
          {$or: [
               { _id: id },
               { parentId: id }
           ]},
          {$set:{
               isDeleted: true,
               deletedAt: Date.now()
            }},
             { new: true }
          )
             assert(assetGroups, createError(StatusCodes.REQUEST_TIMEOUT, "Request Timeout"))
             return {"msg":"Asset groups and their associated children have been successfully deleted."}
} 




export default assetGroupService;